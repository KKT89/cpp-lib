{"config":{"lang":["ja"],"separator":"[\\s\\-\u3000\u3001\u3002\uff0c\uff0e]+","pipeline":["stemmer"]},"docs":[{"location":"","title":"\ud83d\udcda Library Files","text":""},{"location":"#sample","title":"sample","text":"<ul> <li><code>sample.hpp</code></li> </ul>"},{"location":"#graph","title":"Graph","text":"<ul> <li>Bellman Ford (\u8ca0\u306e\u6709\u5411\u9589\u8def\u691c\u51fa)</li> </ul>"},{"location":"library/graph/bellman_ford/","title":"Bellman Ford (\u8ca0\u9589\u8def\u691c\u51fa)","text":""},{"location":"library/graph/bellman_ford/#reference","title":"Reference","text":"<ul> <li>ABC137-E:Coins Respawn ~\u8ca0\u9589\u8def\u691c\u51fa\u306b\u3064\u3044\u3066~ - \u601d\u8003\u306e\u5893\u5834</li> </ul>"},{"location":"library/graph/bellman_ford/#code","title":"Code","text":"<pre><code>#pragma once\n\ntemplate &lt;typename T&gt; struct BellmanFord {\n  private:\n    static constexpr T INF = numeric_limits&lt;T&gt;::max() / 2 - 1;\n\n    struct Edge {\n        int to;\n        T cost;\n    };\n\n    int n;\n    vector&lt;vector&lt;Edge&gt;&gt; G;\n    vector&lt;T&gt; dist;\n\n  public:\n    explicit BellmanFord(int n) : n(n), G(n), dist(n, INF) {}\n\n    void add_edge(int from, int to, T cost) { G[from].emplace_back(to, cost); }\n    template &lt;class Iter&gt; void build(Iter first, Iter last) {\n        dist.assign(n, INF);\n        for (auto it = first; it != last; ++it) {\n            dist[*it] = 0;\n        }\n        relax_edges();\n        spread_neg_cycles();\n    }\n    void build(int s) { build(&amp;s, &amp;s + 1); }\n\n    [[nodiscard]] bool reachable(int v) const { return dist[v] != INF; }\n    [[nodiscard]] bool on_negative_cycle(int v) const { return dist[v] == -INF; }\n    [[nodiscard]] bool valid(int v) const { return reachable(v) and !on_negative_cycle(v); }\n    [[nodiscard]] T distance(int v) const { return dist[v]; }\n\n  private:\n    // \u30d9\u30eb\u30de\u30f3\u30d5\u30a9\u30fc\u30c9\n    void relax_edges() {\n        for (int i = 0; i &lt; n; ++i) {\n            bool updated = false;\n            for (int u = 0; u &lt; n; ++u) {\n                if (dist[u] == INF) continue;\n                for (auto [v, w] : G[u]) {\n                    if (dist[v] &gt; dist[u] + w) {\n                        dist[v] = dist[u] + w;\n                        if (i == n - 1 || dist[v] &lt; -INF) dist[v] = -INF;\n                        updated = true;\n                    }\n                }\n            }\n            if (!updated) break;\n        }\n    }\n    // \u8ca0\u9589\u8def\u3092BFS\u3067\u4f1d\u64ad\u3055\u305b\u308b\n    void spread_neg_cycles() {\n        queue&lt;int&gt; q;\n        vector&lt;bool&gt; used(n, false);\n        for (int i = 0; i &lt; n; ++i) {\n            if (dist[i] == -INF) {\n                used[i] = true;\n                q.push(i);\n            }\n        }\n        while (!q.empty()) {\n            int u = q.front();\n            q.pop();\n            for (auto [v, w] : G[u]) {\n                if (!used[v]) {\n                    used[v] = true;\n                    dist[v] = -INF;\n                    q.push(v);\n                }\n            }\n        }\n    }\n};\n</code></pre>"},{"location":"library/sample/sample/","title":"Sample Library (a+b)","text":"<p>\u30b5\u30f3\u30d7\u30eb\u6587\u7ae0\u3067\u3059\u3002\u6570\u5f0f\u3082\u66f8\u3051\u308b\u3088\u3046\u306b\u306a\u308a\u307e\u3057\u305f\u3002\\(a+b\\) $$ \\sum_{i=1}^{n} = n(n+1)/2 $$ \u3042\u3042\u3042</p> <p>Failure</p> <p>\u3053\u308c\u306f\u5931\u6557\u3067\u3059\u3002</p> <p>Bug</p> <p>\u3053\u308c\u306f\u30d0\u30b0\u3067\u3059\u3002</p> <p>Summary</p> <p>\u3053\u308c\u306f\u6982\u8981\u3067\u3059\u3002</p> <p> \u30d3\u30eb\u30c9\u6210\u529f (\u30a2\u30a4\u30b3\u30f3\u3082\u4f7f\u3048\u307e\u3059)</p> <pre><code>#pragma once\n\n// sample.hpp\nint add(int a, int b){\n    return a + b;\n}\n</code></pre>"}]}